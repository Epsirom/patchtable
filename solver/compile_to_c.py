
import sys
import json
import numpy
import os
from parse_args import parse_args

use_line = True

FIRFilter        = 'FIRFilter'
IIRFilter        = 'IIRFilter'
FilterAdd        = 'FilterAdd'
FilterDownsample = 'FilterDownsample'
FilterUpsample   = 'FilterUpsample'

compiler_args = ' -O3 -funroll-loops -DBUILD_DEBUG=0 -I/opt/X11/include -I ../extern/jsoncpp-src-0.5.0/bin/include -L ../extern/jsoncpp-src-0.5.0/bin -I ../../Halide/include -L ../../Halide/bin array.cpp timer.cpp util.cpp params.cpp -fmax-errors=3 -std=c++0x -L/opt/X11/lib -ladept -lX11 -lpthread -lpng -lHalide -ldl -ljson -llbfgs -Wall'

def usage():
    print >> sys.stderr, 'compile_to_c.py pareto.json idx out.cpp [-compile 0[|1]] [-test 0[|1]] [-iters n] [-channels 3]'
    print >> sys.stderr, '  [-optimize_fir 1[|0]] [-optimize_iir 1[|0]] [-vectorize 1[|0]]'
    print >> sys.stderr, '  Emits C code, and optionally also compiles a binary.'
    print >> sys.stderr, '  If test is 1 then tests against solve_kernel, printing Fail if failed.'
    sys.exit(1)

def paired_intify_list(L):
    ans = []
    for x in L:
        try:
            prefix = 'Filter'
            assert x.startswith(prefix)
            ans.append((int(x[len(prefix):]), x))
        except:
            ans.append((x, x))
    return ans

def system(s):
    print s
    os.system(s)
    
def main():
    (args, kw) = parse_args('optimize_fir optimize_iir compile iters test vectorize channels'.split(), usage)
    if len(args) < 3:
        usage()
        
    pareto_filename = args[0]
    program_idx = int(args[1])
    base = json.loads(open(pareto_filename, 'rt').read())[program_idx]
    program = base['program']
    out_filename = args[2]    
    optimize_fir = int(kw.get('optimize_fir', '1'))
    optimize_iir = int(kw.get('optimize_iir', '1'))
    compile = int(kw.get('compile', '0'))
    iters = int(kw.get('iters', 2))
    test = int(kw.get('test', '0'))
    vectorize = int(kw.get('vectorize', '1'))
    channels = int(kw.get('channels', '3'))
    if channels == 1:
        vectorize = False
    #if test:
    #    compile = 1

    f = open(out_filename, 'wt')
    
    if vectorize:
        header = """
        typedef real color __attribute__ ((vector_size (16)));
        typedef color atom;
        """
        conversion = """
        Array<atom> Input(Input0.sizes);
        for (int y = 0; y < Input.height(); y++) {
            for (int x = 0; x < Input.width(); x++) {
                Input(y, x) = (atom) { Input0(y, x, 0), Input0(y, x, 1), Input0(y, x, 2), 0.0 };
            }
        }
        """
    else:
        header = 'typedef real atom;'
        conversion = '#define Input Input0'
        
    print >> f, r"""
/* Generated by compile_to_c.py */

#include <stdio.h>
#include "array.h"
#include "timer.h"
    
typedef float real;
#define NUM_ITERS %(iters)s
#define NUM_CHANNELS(img) %(channels)d

%(header)s

int main(int argc, char *argv[]) {
    argc--;
    argv++;
    if (argc != 2) {
        fprintf(stderr, "usage: ./program in.png out.png|out.txt    -- Prints run time to stdout\n");
        exit(1);
    }
    const char *in_filename = argv[0];
    const char *out_filename = argv[1];
    Array<real> Input0(load_color_image<real>(in_filename));
    if (!strstr(out_filename, ".png")) {
        for (int i = 0; i < Input0.nelems; i++) { Input0.data[i] *= (1.0/255.0); }
    }
    %(conversion)s
    
    double time_report = 0.0;
    
    for (int iter = 0; iter < NUM_ITERS; iter++) {
        double T0 = wall_time();
""" % locals()

    def declare_image(out_image, in_image):
        print >> f, '        Array<atom> %s(%s.sizes);' % (out_image, in_image)
        
    for (key, output) in sorted(paired_intify_list(program.keys())):
        if key == 'Input':
            continue
            
        sub = program[output]
        filter = sub[0]
        
        input = sub[1]
        print >> f, '       /* %s (%s) */' % (output, filter)
        channels_part = (', NUM_CHANNELS(%s)' % input) if not vectorize else ''
        if filter in [FIRFilter, IIRFilter, FilterAdd]:
            declare_image(output, input)
        elif filter == FilterDownsample:
            print >> f, '        vector<int> %s_sizes({%s.height()/2, %s.width()/2%s});' % (output, input, input, channels_part)
            print >> f, '        Array<atom> %s(%s_sizes);' % (output, output)
        elif filter == FilterUpsample:
            print >> f, '        vector<int> %s_sizes({%s.height()*2, %s.width()*2%s});' % (output, input, input, channels_part)
            print >> f, '        Array<atom> %s(%s_sizes);' % (output, output)
        else:
            raise ValueError(filter)

        if vectorize:
            begin_c_loop = end_c_loop = ''
        else:
            begin_c_loop = """
                        for (int c = 0; c < NUM_CHANNELS(%s); c++) {
                       """ % output
        
            end_c_loop = """
                        }
                       """

        def scalar(v):
            s = '%.16g' % v
            if not vectorize:
                return s
            else:
                return '((atom) {%s, %s, %s, 0})' % (s, s, s)
        
 
        scale = ''
        if key == 'OUT':
            scale = '%s * ' % scalar(base['scale'])
        xdir = 1
        ydir = 0
        if filter == IIRFilter:
            xdir = sub[4]
            ydir = sub[5]
        
        injectL = []
        def pixel(image, y, x):
            if use_line:
                y = y.replace(' ', '').strip()
                if y.endswith('+0'):
                    y = y[:len(y)-len('+0')]
                sym = '%s_line%s' % (image, y.strip().replace('+', 'p').replace('-', 'm').replace('*','t').replace('/','d').replace('(', '').replace(')', '').replace(' ', ''))
                inject_str = 'atom *%s = &(%s(%s,0%s));' % (sym, image, y, ',0' if not vectorize else '')
                if inject_str not in injectL:
                    injectL.append(inject_str)
                if vectorize:
                    return '%s[%s]' % (sym, x)
                else:
                    return '%s[(%s)*NUM_CHANNELS(%s)+(c)]' % (sym, x, image)
            else:
                return '%s(%s, %s%s)' % (image, y, x, ', c' if not vectorize else '')
            
        def get_open_loop(reverse=False, ymin='0', ymax=None, xmin='0', xmax=None, inner=False):
            if ymax is None:
                ymax = '%s.height()' % output
            if xmax is None:
                xmax = '%s.width()' % output
            if reverse:
                inner_part = """
                    for (int x = %s-1; x >= %s; x--) {
                        %s
                        """ % (xmax, xmin, begin_c_loop)
                if inner:
                    return inner_part
                return """
                for (int y = %s-1; y >= %s; y--) {
                    %s%s
                """ % (ymax, ymin, '\n'.join(injectL), inner_part)
            else:
                inner_part = """
                    for (int x = %s; x < %s; x++) {
                        %s
                        """ % (xmin, xmax, begin_c_loop)
                if inner:
                    return inner_part
                return """
                for (int y = %s; y < %s; y++) {
                    %s%s
                """ % (ymin, ymax, '\n'.join(injectL), inner_part)

        #if filter != FIRFilter and filter != IIRFilter:
        #    close_loop = True
        #    print_open_loop()
            
        def get_close_loop(inner=False):
            inner_part = """
                        %s
                    }
                    """ % end_c_loop
            if inner:
                return inner_part
            return """
                    %s
                }
            """ % inner_part
        
        def get_filter_info(K):
            h = len(K)
            w = len(K[0])
            hh = h/2
            hw = w/2
            
            dxL = []
            dyL = []
            KxL = []
            KyL = []
            for dy in range(-hh, hh+1):
                for dx in range(-hw, hw+1):
                    Ky = hh-dy
                    Kx = hw-dx
                    if 0 <= Ky < h and 0 <= Kx < w and K[Ky][Kx] != 0:
                        dxL.append(dx)
                        dyL.append(dy)
                        KxL.append(Kx)
                        KyL.append(Ky)

            if len(dxL):
                dx_min = numpy.min(dxL)
                dx_max = numpy.max(dxL)
                dy_min = numpy.min(dyL)
                dy_max = numpy.max(dyL)
            else:
                dx_min = dx_max = dy_min = dy_max = 0
            return (dxL, dyL, KxL, KyL, dx_min, dy_min, dx_max, dy_max)

        def get_output():
            return pixel(output, 'y', 'x') + ' = %s(' % scale #'%s%s =%s(' % (output, p0, scale)
                    
        def get_convolve(K, do_check_x=True, do_check_y=True, write_output=True):
            ans = ''
            (dxL, dyL, KxL, KyL, dx_min, dy_min, dx_max, dy_max) = get_filter_info(K)
            if write_output:
                ans += get_output()
            needs_plus = False
            for i in range(len(dxL)):
                dx = dxL[i]
                dy = dyL[i]
                
                yp = '(y + %d)' % dy
                xp = '(x + %d)' % dx
                if needs_plus:
                    ans += '+\n'
                ycheck = '(unsigned) %s < (unsigned) %s.height()' % (yp, input)
                xcheck = '(unsigned) %s < (unsigned) %s.width()' % (xp, input)
                needs_xcheck = do_check_x and (dx != 0)
                needs_ycheck = do_check_y and (dy != 0)
                if needs_xcheck and needs_ycheck:
                    check = xcheck + ' && ' + ycheck
                elif needs_xcheck:
                    check = xcheck
                elif needs_ycheck:
                    check = ycheck
                else:
                    check = '1'
                body = '%s * %s' % (scalar(K[KyL[i]][KxL[i]]), pixel(input, yp, xp))
                if check == '1':
                    ans += body
                else:
                    ans += '((%s) ? %s: %s)' % (check, body, scalar(0.0))
                needs_plus = True
            if not needs_plus:
                ans += scalar(0.0)
            ans += ');'
            return ans

        def get_ordinary_loop(s, ymin='0', ymax=None, xmin='0', xmax=None, reverse=False, add_paren=True, inner=False):
            if add_paren:
                s += ');'
            return get_open_loop(reverse, ymin, ymax, xmin, xmax, inner=inner) + s + get_close_loop(inner)
            
        def print_ordinary_loop(*args, **kw):
            s = get_ordinary_loop(*args, **kw)
            print >> f, s
        
        def get_bounds(dx_min, dy_min, dx_max, dy_max):
            nocheck_ymin = str(max(-dy_min, 0))
            nocheck_xmin = str(max(-dx_min, 0))
            if dy_max <= 0:
                nocheck_ymax = ('%s.height()' % input)
                has_ymax = False
            else:
                nocheck_ymax = ('%s.height()-%d' % (input, dy_max))
                has_ymax = True
            if dx_max <= 0:
                nocheck_xmax = ('%s.width()'  % input)
                has_xmax = False
            else:
                nocheck_xmax = ('%s.width() -%d' % (input, dx_max))
                has_xmax = True
            return (nocheck_xmin, nocheck_ymin, nocheck_xmax, nocheck_ymax, has_xmax, has_ymax)

        p0 = ('y', 'x')
        if filter == FilterAdd:
            s = get_output()
            s += pixel(input, *p0)
            for arg in sub[2:]:
                s += '+ ' + pixel(arg, *p0)
            print_ordinary_loop(s)
        elif filter == FilterDownsample:
            s = get_output()
            s += pixel(input, 'y*2', 'x*2')
            print_ordinary_loop(s)
        elif filter == FilterUpsample:
            s = get_output()
            s += '((x&1)==0 && (y&1) == 0) ? %s: %s' % (pixel(input, 'y/2', 'x/2'), scalar(0.0))
            print_ordinary_loop(s)
        elif filter == FIRFilter:
            K = sub[2]
#            print 'Kernel sum:', numpy.sum(numpy.array(K).flatten())
            (dxL, dyL, KxL, KyL, dx_min, dy_min, dx_max, dy_max) = get_filter_info(K)
            
            if optimize_fir:
                (nocheck_xmin, nocheck_ymin, nocheck_xmax, nocheck_ymax, has_xmax, has_ymax) = get_bounds(dx_min, dy_min, dx_max, dy_max)
                
                if int(nocheck_ymin) > 0:
                    s = get_convolve(K, True, True)
                    print_ordinary_loop(s, '0', nocheck_ymin, add_paren=False)
    
                injectL[:] = []
                s = ''
                c_xcheck = get_convolve(K, True, False)
                c_none   = get_convolve(K, False, False)

                if int(nocheck_xmin) > 0:
                    s += get_ordinary_loop(c_xcheck, xmin='0', xmax=nocheck_xmin, add_paren=False, inner=True)
                s += get_ordinary_loop(c_none, xmin=nocheck_xmin, xmax=nocheck_xmax, add_paren=False, inner=True)
                if has_xmax:
                    s += get_ordinary_loop(c_xcheck, xmin=nocheck_xmax, add_paren=False, inner=True)
                
                inject_join = '\n'.join(injectL)
                print >> f, """
                for (int y = %(nocheck_ymin)s; y < %(nocheck_ymax)s; y++) {
                    %(inject_join)s
                    %(s)s
                }
                """ % locals()
                injectL[:] = []
                
                if has_ymax:
                    s = get_convolve(K, True, True)
                    print_ordinary_loop(s, nocheck_ymax, add_paren=False)
            else:
                # Case optimize_fir is False
                s = get_convolve(K, True, True)
                print_ordinary_loop(s, add_paren=False)
            
                        
        elif filter == IIRFilter:
            print >> f, '       /* xdir=%d, ydir=%d */' % (xdir, ydir)
            K = sub[2]
            F = sub[3]
            hw = len(K)/2
            w = len(K)
            
            def check_func(yp, xp):
                xcheck = '(unsigned) %s < (unsigned) %s.width()' % (xp, input)
                ycheck = '(unsigned) %s < (unsigned) %s.height()' % (yp, input)
                needs_xcheck = xp.replace(' ', '').replace('+0', '').replace('-0', '') != 'x'
                needs_ycheck = yp.replace(' ', '').replace('+0', '').replace('-0', '') != 'y'
                if needs_xcheck and needs_ycheck:
                    return xcheck + ' && ' + ycheck
                elif needs_xcheck:
                    return xcheck
                elif needs_ycheck:
                    return ycheck
                else:
                    return '1'
            
            def plus_join(addL):
                if len(addL):
                    return '\n+'.join(addL)
                else:
                    return scalar(0.0)

            def get_iir_body(needs_check=True):
                s = get_output()
                addL = []
                for dx in range(-hw, hw+1):
                    if 0 <= hw-dx < w:
                        yp = 'y + %d' % (dx if ydir else 0)
                        xp = 'x + %d' % (dx if xdir else 0)
                        check = check_func(yp, xp)
                        if K[hw-dx]:
                            lookup = '(%s * %s)' % (scalar(K[hw-dx]), pixel(input, yp, xp))
                            addL.append(('((%s) ? %s: %s)' % (check, lookup, scalar(0.0))) if needs_check else lookup) 
                s += plus_join(addL) + ')'
                addL = []
                for i in range(len(F)):
                    yp = 'y+%d' % (-((i+1)*ydir))
                    xp = 'x+%d' % (-((i+1)*xdir))
                    check = check_func(yp, xp)
                    if F[i]:
                        lookup = '(%s * %s)' % (scalar(F[i]), pixel(output, yp, xp))
                        addL.append(('((%s) ? %s: %s)' % (check, lookup, scalar(0.0))) if needs_check else lookup)
                s += '+' + plus_join(addL) + ';'
                return s
                
            reverse = (xdir < 0 or ydir < 0)
            if not optimize_iir:
                s = get_iir_body()
                print_ordinary_loop(s, reverse=reverse, add_paren=False)
            else:
                (dxL, dyL, KxL, KyL, dx_min, dy_min, dx_max, dy_max) = get_filter_info([K] if xdir != 0 else [[elem] for elem in K])
                for i in range(len(F)):
                    if F[i]:
                        if xdir:
                            dx = -((i+1)*xdir)
                            dx_min = min(dx_min, dx)
                            dx_max = max(dx_max, dx)
                        else:
                            dy = -((i+1)*ydir)
                            dy_min = min(dy_min, dy)
                            dy_max = max(dy_max, dy)
                            
                (nocheck_xmin, nocheck_ymin, nocheck_xmax, nocheck_ymax, has_xmax, has_ymax) = get_bounds(dx_min, dy_min, dx_max, dy_max)
                
                iirc = get_iir_body()
                iir  = get_iir_body(False)
                
                part1 = ''
                
                if int(nocheck_ymin) > 0:
                    part1 = get_ordinary_loop(iirc, ymin='0', ymax=nocheck_ymin, add_paren=False, reverse=reverse)
    
                part2 = []
                if int(nocheck_xmin) > 0:
                    part2.append(get_ordinary_loop(iirc, xmin='0', xmax=nocheck_xmin, add_paren=False, reverse=reverse, inner=True))
                part2.append(get_ordinary_loop(iir, xmin=nocheck_xmin, xmax=nocheck_xmax, add_paren=False, reverse=reverse, inner=True))
                if has_xmax:
                    part2.append(get_ordinary_loop(iirc, xmin=nocheck_xmax, add_paren=False, reverse=reverse, inner=True))
                    
                if reverse:
                    part2 = part2[::-1]
                part2 = '\n'.join(part2)
                
                inject_join = '\n'.join(injectL)
                if not reverse:
                    part2 = """
                    for (int y = %(nocheck_ymin)s; y < %(nocheck_ymax)s; y++) {
                        %(inject_join)s
                        %(part2)s
                    }
                    """ % locals()
                else:
                    part2 = """
                    for (int y = (%(nocheck_ymax)s)-1; y >= %(nocheck_ymin)s; y--) {
                        %(inject_join)s
                        %(part2)s
                    }
                    """ % locals()
                
                part3 = ''
                if has_ymax:
                    part3 = get_ordinary_loop(iirc, ymin=nocheck_ymax, add_paren=False, reverse=reverse)
                    
                
                parts = [part1, part2, part3]
                if reverse:
                    parts = parts[::-1]
                info = """/* nocheck_xmin: %(nocheck_xmin)s, nocheck_ymin: %(nocheck_ymin)s, nocheck_xmax: %(nocheck_xmax)s, nocheck_ymax: %(nocheck_ymax)s */""" % locals() 
                print >> f, info + '\n' + '\n'.join(parts)
            
    if not vectorize:
        conversion = '#define OUT1 OUT\n'
    else:
        conversion = """
            vector<int> OUT1_sizes({OUT.height(), OUT.width(), NUM_CHANNELS(OUT1)});
            Array<real> OUT1(OUT1_sizes);
            for (int y = 0; y < OUT1.height(); y++) {
                for (int x = 0; x < OUT1.width(); x++) {
                    OUT1(y, x, 0) = OUT(y, x)[0];
                    OUT1(y, x, 1) = OUT(y, x)[1];
                    OUT1(y, x, 2) = OUT(y, x)[2];
                }
            }
        """
    
    print >> f, r"""
        double T1 = wall_time();
        time_report = T1 - T0;
        if (iter == NUM_ITERS - 1) {
            %(conversion)s
            if (strstr(out_filename, ".png")) {
                for (int y = 0; y < OUT1.height(); y++) {
                    for (int x = 0; x < OUT1.width(); x++) {
                        for (int c = 0; c < NUM_CHANNELS(OUT1); c++) {
                            if (OUT1(y, x, c) > 255) { OUT1(y, x, c) = 255; }
                            else if (OUT1(y, x, c) < 0) { OUT1(y, x, c) = 0; }
                        }
                    }
                }
                
                save_color_image<real>(OUT1, out_filename);
            } else {
                vector<int> slice_sizes({OUT1.height(), OUT1.width()});
                Array<real> slice(slice_sizes);
                for (int y = 0; y < OUT1.height(); y++) {
                    for (int x = 0; x < OUT1.width(); x++) {
                        slice(y, x) = OUT1(y, x, 0);
                    }
                }
                save_matrix<real>(slice, out_filename);
            }
        }
    }
    
    printf("%%f\n", time_report);
    return 0;
}
""" % locals()
    f.close()
    
    out_binary = os.path.splitext(out_filename)[0]

    if compile:
        system('g++ %s -o %s %s -I %s' % (out_filename, out_binary, compiler_args, os.getcwd()))

    if test:
        import Image
        import pylab
        
        width = 100
        in_image = 'unit%d.png'%width
        if not os.path.exists(in_image):
            I = numpy.zeros((width, width, 3), 'uint8')
            I[width/2,width/2,:] = 255
            Image.fromarray(I).save(in_image)
        out_prefix = os.path.splitext(out_filename)[0]
        out_compiled = out_prefix + '_compiled.txt'
        out_ground = out_prefix + '_ground.txt'
        os.system('%s %s %s > /dev/null' % (os.path.abspath(out_binary), in_image, out_compiled))
        os.system('./solve_kernel apply unit3.txt %s %d %s -target_w %d' % (pareto_filename, program_idx, out_ground, width))
        A = numpy.loadtxt(out_compiled)
        B = numpy.loadtxt(out_ground)
        #print A.shape
        #print B.shape
        Af = A.flatten()
        Bf = B.flatten()
        Anorm = numpy.linalg.norm(Af)
        Bnorm = numpy.linalg.norm(Bf)
        diff = numpy.linalg.norm(Af-Bf)/numpy.linalg.norm(Bf)
        if diff > 1e-5:
            print 'Fail        (%10f, %10f, %10g)' % (Anorm, Bnorm, diff)
            sys.exit(1)
        else:
            print 'Success     (%10f, %10f, %10g)' % (Anorm, Bnorm, diff)
        #print numpy.linalg.norm(Af), numpy.linalg.norm(Bf), numpy.linalg.norm(Af-Bf)/numpy.linalg.norm(Bf)
        #pylab.suptitle('Ground truth')
        #pylab.imshow(B)
        #pylab.show()
        #pylab.suptitle('Compiled result')
        #pylab.imshow(A)
        #pylab.show()
        
if __name__ == '__main__':
    main()
