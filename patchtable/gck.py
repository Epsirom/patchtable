
"""
Grey Code Kernels -- 2D Walsh-Hadamard kernels
File gck.h is generated by gck.py (do not hand-edit gck.h)

Interface:

   template<class in_type, class out_type>
   void gck(const Array<in_type> &in, Array<out_type> &out, int n, int nchroma, int patch_w);

See: http://www.faculty.idc.ac.il/toky/publications/journal/gck.pdf

The kernels are computed in "snake" order (see Fig 7). The input image
is assumed to have 3 channels, and the output image has 3*n channels,
where n is the number of requested kernels. If nchroma != n then the
output image has n+nchroma*2 channels.
"""

import math
import numpy

min_dims = 3
max_dims = 12
dimL = range(min_dims, max_dims+1) + [20, 25, 30]

min_nchroma = 0
max_nchroma = 3

use_incremental = False

channels = 3
patch_w_L = [8] #[4, 8]

ROW = 0
COL = 1

def snake_order(w):
    L = [(row, col) for row in range(w) for col in range(w)]
    return sorted(L, key=lambda (row, col): max(row, col) + 0.5 + (row-col+w) * (1.0/(4*w)) * (-1 if max(row,col)%2 == 0 else 1))

def get_delta_and_sign(alpha1, alpha2):
    assert len(alpha1) == len(alpha2)
    idx = [alpha1[i] != alpha2[i] for i in range(len(alpha1))].index(True)
    return (2**(idx), alpha1[idx], alpha2[idx])
    
def wh_basis(w, alpha=False):
    # List of w lists, each of length w, containing WH basis vectors in grey code sequence. If alpha is True returns alpha indices.
    # For example, wh_basis(4) = [[1, 1, 1, 1], [1, 1, -1, -1], [1, -1, -1, 1], [1, -1, 1, -1]].
    k = int(math.log(w, 2))
    ans = []
    sign_level = [1 for i in range(k)]
    def f(L, level, alpha_L):
        L1 = L + [ sign_level[level] * x for x in L]
        L2 = L + [-sign_level[level] * x for x in L]
        alpha_L1 = alpha_L + [ sign_level[level]]
        alpha_L2 = alpha_L + [-sign_level[level]]
        sign_level[level] = -sign_level[level]
        if len(L1) == w:
            if not alpha:
                ans.extend([L1, L2])
            else:
                ans.extend([alpha_L1, alpha_L2])
        else:
            f(L1, level+1, alpha_L1)
            f(L2, level+1, alpha_L2)
    f([1], 0, [])
    return ans

def test_wh_basis():
    assert wh_basis(4) == [[1, 1, 1, 1], [1, 1, -1, -1], [1, -1, -1, 1], [1, -1, 1, -1]]
    assert wh_basis(8) == [[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, -1, -1, -1, -1],
                               [1, 1, -1, -1, -1, -1, 1, 1], [1, 1, -1, -1, 1, 1, -1, -1],
                               [1, -1, -1, 1, 1, -1, -1, 1], [1, -1, -1, 1, -1, 1, 1, -1],
                               [1, -1, 1, -1, -1, 1, -1, 1], [1, -1, 1, -1, 1, -1, 1, -1]]
    assert wh_basis(4, alpha=True) == [[1, 1], [1, -1], [-1, -1], [-1, 1]]
    assert wh_basis(8, alpha=True) == [[1, 1, 1], [1, 1, -1], [1, -1, -1], [1, -1, 1],
                                       [-1, -1, 1], [-1, -1, -1], [-1, 1, -1], [-1, 1, 1]]

    print 'Test wh_basis:   OK'
    
def test():
    test_wh_basis()
    
def main():
    test()

    doc = __doc__
    s = """
/*
%(doc)s
*/

#ifndef _gck_h
#define _gck_h
    
#define ASSIGN_ARRAY 1
#define ARRAY_USE_OPENCV 1
#include "../solver/array.h"
""" % locals()
    
    sclass = ''

    sfunc = """

#define GCK_PATCHTABLE(in, out, params) gck<float, float>(in, out, params->ndims-params->nchroma*2, params->nchroma, params->patch_w)

/* gck<in_type, out_type>(in, out, n, nchroma, patch_w) -- Calculates grey code kernels */
template<class in_type, class out_type>
void gck(const Array<in_type> &in, Array<out_type> &out, int n, int nchroma, int patch_w) {
#if TABLE_EXTRA_VERBOSE
    printf("gck()\\n"); fflush(stdout);
#endif
    if (0) {
""" % locals()
    
    for patch_w in patch_w_L:
        sfunc += """
    } else if (patch_w == %(patch_w)d) {
        if (0) {""" % locals()
        for nchroma in range(min_nchroma, max_nchroma+1):
            sfunc += """
        } else if (nchroma == %(nchroma)d) {
            if (0) { }
            """ % locals()
            
            for dims in dimL:
                n = dims-nchroma*2
                sfunc += """
            else if (n == %(n)d) { gck_%(patch_w)d<in_type, out_type, %(n)d, %(nchroma)d>(in, out); }""" % locals()
            sfunc += """
            else { fprintf(stderr, "gck: n, nchroma unsupported: %d, %d\\n", n, nchroma); exit(1); }
            """
        sfunc += """
        } else { fprintf(stderr, "gck: n, nchroma unsupported: %d, %d\\n", n, nchroma); exit(1); }
        """
        
    sfunc += """
    } else { fprintf(stderr, "gck: patch_w unsupported: %d\\n", patch_w); exit(1); }
}
    
    """
    
    channels = 3
    for patch_w in patch_w_L:
        max_delta = patch_w/2
        
        pad_vars = """
    const int rpad = %(patch_w)d/2;
    const int lpad = rpad-1;
    const int lread = rpad, rread = lpad;
    const int pad = lpad+rpad;
        """ % locals()
        
        static_pad_vars = pad_vars.replace('const ', 'static const ')
        
        sclass += """
template<class in_type, class out_type, int n, int nchroma>
class IncrementalGCK_%(patch_w)d { public:
    const Array<in_type> &in;
    Array<out_type> &out;
    Array<out_type> temp;
    %(static_pad_vars)s
    
    IncrementalGCK_%(patch_w)d (const Array<in_type> &in_, Array<out_type> &out_)
        :in(in_), out(out_) {
        out.resize(in.height()+pad, in.width()+pad, n+nchroma*2);
        temp.resize(out.height(), out.width(), %(channels)d);
    }

    void compute_all() {
        for (int y = 0; y < out.height(); y++) {
            for (int x = 0; x < out.width(); x++) {
                compute(x, y);
            }
        }
    }    
    
    void compute(int x, int y) {
        /* Compute kernel 0 (box of size w x w). First convolve horizontally into temp array. */
        {
            int ysrc = y-lpad;
            if (x == 0) {
                for (int c = 0; c < %(channels)d; c++) {
                    temp(y, 0, c) = in.get_zero(ysrc, 0, c);
                }
            } else {
                int xsrc = x-lpad;
                for (int c = 0; c < %(channels)d; c++) {
                    temp(y, x, c) = temp(y, x-1, c) + ((out_type) in.get_zero(ysrc, xsrc+rread, c)) - ((out_type) in.get_zero(ysrc, xsrc-lread-1, c));
                }
            }
        }

        /* Convolve vertically into first kernel output. */
        {
            if (y == 0) {
                for (int c = 0; c < %(channels)d; c++) {
                    out(0, x, c) = temp(rread, x, c);
                }
            } else {
                for (int c = 0; c < %(channels)d; c++) {
                    out(y, x, c) = out(y-1, x, c) + ((out_type) temp.get_zero(y+rread, x, c)) - ((out_type) temp.get_zero(y-lread-1, x, c));
                }
            }
        }

        """ % locals()

        hconv_init_row = """
        int ysrc = y-lpad;
        {
            for (int c = 0; c < %(channels)d; c++) {
                temp(y, 0, c) = in.get_zero(ysrc, 0, c);
            }
        }
        """ % locals()
        
        hconv_boundscheck = """
            int xsrc = x-lpad;
            for (int c = 0; c < %(channels)d; c++) {
                temp(y, x, c) = temp(y, x-1, c) + ((out_type) in.get_zero(ysrc, xsrc+rread, c)) - ((out_type) in.get_zero(ysrc, xsrc-lread-1, c));
            }
        """ % locals()
        
        hconv_full_row_boundscheck = """
        %(hconv_init_row)s
#if TABLE_EXTRA_VERBOSE
        printf("gck second pixel in row\\n"); fflush(stdout);
#endif
        for (int x = 1; x < out.width(); x++) {
            %(hconv_boundscheck)s
        }
#if TABLE_EXTRA_VERBOSE
        printf("done with row\\n"); fflush(stdout);
#endif
        """ % locals()
        
        vconv_full_row_boundscheck = """
        for (int x = 0; x < out.width(); x++) {
            for (int c = 0; c < %(channels)d; c++) {
                out(y, x, c) = out(y-1, x, c) + ((out_type) temp.get_zero(y+rread, x, c)) - ((out_type) temp.get_zero(y-lread-1, x, c));
            }
        }
        """ % locals()
        
        s += """        
/* gck_%(patch_w)d<in_type, out_type, n>(in, out) -- Convolve by n %(patch_w)d x %(patch_w)d kernels (per channel) */
template<class in_type, class out_type, int n, int nchroma> void gck_%(patch_w)d(const Array<in_type> &in, Array<out_type> &out) {
#if TABLE_EXTRA_VERBOSE
    printf("gck_%(patch_w)d()\\n"); fflush(stdout);
#endif
    ASSERT2(%(channels)d == in.channels(), "expected input to have %(channels)d channels");

    /* Compute full convolution, so pad right side by rpad and left side by lpad.
       Each kernel reads lread entries to the left of the output pixel and rread entries to the right (same for above/below). */
    %(pad_vars)s
    
    const int out_channels = n+nchroma*2;
    static Array<out_type> temp;
    out.resize(in.height()+pad, in.width()+pad, out_channels);
    temp.resize(out.height(), out.width(), %(channels)d);
    
#if TABLE_EXTRA_VERBOSE
    double T0 = wall_time();
    printf("gck begin H conv()\\n"); fflush(stdout);
#endif

     /* Compute kernel 0 (box of size w x w). First convolve horizontally into temp. */
    int hconv_xmin = 2*rpad;
    int hconv_xmax = in.width()+lpad-rread;
    int hconv_ymin = lpad;
    int hconv_ymax = in.height()+lpad;
    
    for (int y = 0; y < hconv_ymin; y++) {
        %(hconv_full_row_boundscheck)s
    }
#if TABLE_EXTRA_VERBOSE
    printf("gck mid H conv()\\n"); fflush(stdout);
#endif

#if TABLE_OPENMP
#pragma omp parallel for
#endif
    for (int y = hconv_ymin; y < hconv_ymax; y++) {
        %(hconv_init_row)s

        out_type *temp_x = &temp(y, 0, 0);
        out_type *temp_x1 = &temp.get_unsafe(y, -1, 0);
        const in_type *in_right = &in.get_unsafe(ysrc, -lpad+rread, 0);
        const in_type *in_left = &in.get_unsafe(ysrc, -lpad-lread-1, 0);

        for (int x = 1; x < hconv_xmin; x++) {
            %(hconv_boundscheck)s
        }
        for (int x = hconv_xmin; x < hconv_xmax; x++) {
            for (int c = 0; c < %(channels)d; c++) {
                temp_x[x*%(channels)d+c] = temp_x1[x*%(channels)d+c] + ((out_type) in_right[x*%(channels)d+c]) - ((out_type) in_left[x*%(channels)d+c]);
            }
        }
        for (int x = hconv_xmax; x < out.width(); x++) {
            %(hconv_boundscheck)s
        }
    }
#if TABLE_EXTRA_VERBOSE
    printf("gck last part of H conv()\\n"); fflush(stdout);
#endif

    for (int y = hconv_ymax; y < out.height(); y++) {
        %(hconv_full_row_boundscheck)s
    }

#if TABLE_EXTRA_VERBOSE
    printf("gck begin V conv()\\n"); fflush(stdout);
    double T1 = wall_time();
#endif

    /* Convolve vertically into first kernel output. */
    {
        for (int x = 0; x < out.width(); x++) {
            for (int c = 0; c < %(channels)d; c++) {
                out(0, x, c) = temp(rread, x, c);
            }
        }
    }
    int vconv_ymax = out.height()-rread;
    int vconv_ymin = lread+1;
    
    for (int y = 1; y < vconv_ymin; y++) {
        %(vconv_full_row_boundscheck)s
    }
#if TABLE_EXTRA_VERBOSE
    printf("gck mid V conv()\\n"); fflush(stdout);
#endif
    for (int y = vconv_ymin; y < vconv_ymax; y++) {
        out_type *out_y = &out(y, 0, 0);
        out_type *out_y1 = &out.get_unsafe(y-1, 0, 0);
        out_type *temp_right = &temp.get_unsafe(y+rread, 0, 0);
        out_type *temp_left = &temp.get_unsafe(y-lread-1, 0, 0);
        for (int x = 0; x < out.width(); x++) {
            for (int c = 0; c < %(channels)d; c++) {
                out_y[x*out_channels+c] = out_y1[x*out_channels+c] + temp_right[x*%(channels)d+c] - temp_left[x*%(channels)d+c];
            }
        }
    }
#if TABLE_EXTRA_VERBOSE
    printf("gck last part V conv()\\n"); fflush(stdout);
#endif
    for (int y = vconv_ymax; y < out.height(); y++) {
        %(vconv_full_row_boundscheck)s
    }
#if TABLE_EXTRA_VERBOSE
    double T2 = wall_time();
    printf("gck H conv time: %%f\\n", T1-T0);
    printf("gck V conv time: %%f\\n", T2-T1);
#endif
    
        """ % locals()
        orderL = snake_order(patch_w)
        wh_L = wh_basis(patch_w)
        alpha_L = wh_basis(patch_w, alpha=True)
        assert len(orderL) == len(wh_L)**2, (len(orderL), len(wh_L))
        assert len(wh_L) == len(alpha_L), (len(wh_L), len(alpha_L))
        
        close_braces = ''
        
        calc_check = ''
        calc = ''
        rowdef = set()
        
        for (i, (row, col)) in enumerate(orderL):
            current_V = numpy.asarray(wh_L[col])
            current_H = numpy.asarray(wh_L[row])
#            numpy.savetxt('gck_%d_%03d.txt'%(patch_w, i+1), numpy.outer(current_H, current_V), '%2d')
            if i == 0:
                continue
            horiz = orderL[i][COL] != orderL[i-1][COL]
            if horiz:
                (delta, s1, s2) = get_delta_and_sign(alpha_L[orderL[i-1][COL]], alpha_L[orderL[i][COL]])
            else:
                (delta, s1, s2) = get_delta_and_sign(alpha_L[orderL[i-1][ROW]], alpha_L[orderL[i][ROW]])
            assert set([s1, s2]) == set([-1, 1])
            
            sign = s2
            
            i1 = i+1
            iprev = i-1
            current_channels = '(%(i)d < nchroma ? 3: 1)' % locals()
            c0_current = '(%(i)d < nchroma ? %(i)d*%(channels)d: nchroma*%(channels)d+(%(i)d-nchroma))' % locals()
            c0_prev = '(%(iprev)d < nchroma ? %(iprev)d*%(channels)d: nchroma*%(channels)d+(%(iprev)d-nchroma))' % locals()
            
            if horiz:
                rowdef.add('out_type *out_x%(delta)d = &out(y, x-%(delta)d, 0);' % locals())
                
                check_str = """
                /* Kernel %(i1)d */
                if (n > %(i)d) {
                    for (int c = 0; c < %(current_channels)s; c++) {
                        out(y, x, %(c0_current)s+c) = %(sign)d * out.get_zero(y, x-%(delta)d, %(c0_current)s+c) +
                                                      out(y, x, %(c0_prev)s+c) +
                                                      %(sign)d * out.get_zero(y, x-%(delta)d, %(c0_prev)s+c);
                    }
                }
                """ % locals()
                
                calc_check += check_str
                sclass += check_str
                
                calc += """
                /* Kernel %(i1)d */
                if (n > %(i)d) {
                    for (int c = 0; c < %(current_channels)s; c++) {
                        out_row[%(c0_current)s+c] = %(sign)d * out_x%(delta)d[%(c0_current)s+c] +
                                                      out_row[%(c0_prev)s+c] +
                                                      %(sign)d * out_x%(delta)d[%(c0_prev)s+c];
                    }
                }
                """ % locals()

            else:
                rowdef.add('out_type *out_y%(delta)d = &out(y-%(delta)d, x, 0);' % locals())

                check_str = """
                /* Kernel %(i1)d */
                if (n > %(i)d) {
                    for (int c = 0; c < %(current_channels)s; c++) {
                        out(y, x, %(c0_current)s+c) = %(sign)d * out.get_zero(y-%(delta)d, x, %(c0_current)s+c) +
                                                      out(y, x, %(c0_prev)s+c) +
                                                      %(sign)d * out.get_zero(y-%(delta)d, x, %(c0_prev)s+c);
                    }
                }
                """ % locals()
                
                calc_check += check_str
                sclass += check_str
                
                calc += """
                /* Kernel %(i1)d */
                if (n > %(i)d) {
                    for (int c = 0; c < %(current_channels)s; c++) {
                        out_row[%(c0_current)s+c] = %(sign)d * out_y%(delta)d[%(c0_current)s+c] +
                                                      out_row[%(c0_prev)s+c] +
                                                      %(sign)d * out_y%(delta)d[%(c0_prev)s+c];
                    }
                }
                """ % locals()
            

        rowdef = '\n'.join(rowdef)
        
        sclass += """
    }
};
        """
        
        s += """
#if TABLE_EXTRA_VERBOSE
    printf("gck y first part\\n"); fflush(stdout);
#endif
    for (int y = 0; y < %(max_delta)d; y++) {
        for (int x = 0; x < out.width(); x++) {
            %(calc_check)s
        }
    }
#if TABLE_EXTRA_VERBOSE
    printf("gck y second part\\n"); fflush(stdout);
#endif
    for (int y = %(max_delta)d; y < out.height(); y++) {
        for (int x = 0; x < %(max_delta)d; x++) {
            %(calc_check)s
        }
        for (int x = %(max_delta)d; x < out.width(); x++) {
            out_type *out_row = &out(y, x, 0);
            %(rowdef)s
            %(calc)s
        }
    }
#if TABLE_EXTRA_VERBOSE
    printf("gck y end\\n"); fflush(stdout);
#endif
    """%locals()

        s += """
}
""" % locals()

    if use_incremental:
        s += sclass
    
    s += sfunc
    
    s += """
template<class in_type, class out_type>
void gck_no_pad(const Array<in_type> &in, Array<out_type> &out, int n, int nchroma, int patch_w) {
    int ew = in.width()-patch_w+1;
    int eh = in.height()-patch_w+1;
    int out_channels = n+nchroma*2;
    out.resize(eh, ew, out_channels);
    Array<out_type> temp;
    
    gck<in_type, out_type>(in, temp, n, nchroma, patch_w);
    vector<int> src_start({patch_w-1, patch_w-1, 0});
    vector<int> extent({eh, ew, out_channels});
    vector<int> dest_start({0, 0, 0});
    temp.copy_rect(out, src_start, dest_start, extent); 
}
"""

    s += """
#endif
"""

    with open('gck.h', 'wt') as f:
        f.write(s)
    print 'Wrote gck.h'
    
if __name__ == '__main__':
    main()
