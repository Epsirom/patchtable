
"""
python refine_pareto.py bench.txt pareto_out.txt

Extracts the Pareto frontier from the partial output of a bench.sh script
generated by gen_bench.py (typically these have a large parameter space so
one terminates early to obtain a partial output). Refines that Pareto frontier 
by crossover between adjacent Pareto points. Concatenates all samples to
refined_output.txt (this script does not terminate).
"""

import sys
import random
import os
import subprocess

def update_pareto(bench_file, refine_samples_file, pareto_file):
    L1 = open(bench_file, 'rt').read().strip().split('\n')
    L2 = open(refine_samples_file, 'rt').read().strip().split('\n')
    if L2 == ['']:
        L2 = []
    L = L1 + L2
    temp_concat = '_temp_concat.txt'
    f = open(temp_concat, 'wt')
    f.write('\n'.join(L))
    f.close()
    os.system('python ../solver/pareto.py %s > %s' % (temp_concat, pareto_file))
    pareto_L = open(pareto_file, 'rt').read().strip().split('\n')
    print '='*80
    print 'update_pareto: all points: %d, Pareto points: %d' % (len(L), len(pareto_L))
    print '='*80
    print
    return (L, pareto_L)

def parse_params(x):
    s = x.split(' ', 2)[2]
    lparen = s.index('(')
    rparen = s.index(')')
    s = s[lparen+1:rparen]
    #print s
    L = s.split(' ')
    assert len(L) % 2 == 0
    keys = L[0::2]
    values = L[1::2]
    d = {keys[i]: values[i] for i in range(len(keys))}
    #print d
    return d

def params_to_str(d):
    return ' '.join(key + ' ' + value for (key, value) in d.items())

def run(cmd):
    print cmd
    return subprocess.check_output(cmd, shell=True)

def main():
    args = sys.argv[1:]
    if len(args) < 2:
        print >> sys.stderr, __doc__
        sys.exit(1)

    (bench_file, pareto_file) = args[:2]
    refine_samples_file = '_refine_samples.txt'
    with open(refine_samples_file, 'wt') as f:
        pass

    while 1:
        (all_L, pareto_L) = update_pareto(bench_file, refine_samples_file, pareto_file)
        params_L = [parse_params(x) for x in pareto_L]
        all_params_L = [parse_params(x) for x in all_L]

        i = random.randrange(len(pareto_L))
        if i-1 >= 0 and i+1 < len(pareto_L):
            j = i+1 if random.randrange(2)==0 else i-1
        elif i-1 >= 0:
            j = i-1
        else:
            j = i+1

        success = False
        for tries in range(100):
            cross = dict()
            for key in params_L[i]:
                if key == '-kcoherence' and random.randrange(5) == 0:
                    cross[key] = '20'
                    continue
                if random.randrange(2) == 0:
                    cross[key] = params_L[i].get(key, params_L[j].get(key, None))
                else:
                    cross[key] = params_L[j].get(key, params_L[i].get(key, None))
            if cross != params_L[i] and cross != params_L[j] and not cross in all_params_L:
                success = True
                break

        if not success:
            continue

        #print sorted(list(params_L[i].items()))
        #print sorted(list(params_L[j].items()))
        #print 'Success:'
        #print sorted(list(cross.items()))
        #sys.exit(1)
        bench_out = run('python bench.py ours 1 "%s" -one_vs_many 1' % params_to_str(cross)).strip()

        with open(refine_samples_file, 'at') as f:
            f.write(bench_out + '\n')

if __name__ == '__main__':
    main()
